-- phpMyAdmin SQL Dump
-- version 4.9.4
-- https://www.phpmyadmin.net/
--
-- Хост: 127.0.0.1
-- Время создания: Май 19 2022 г., 16:11
-- Версия сервера: 10.2.12-MariaDB
-- Версия PHP: 5.6.40

SET SQL_MODE = "NO_AUTO_VALUE_ON_ZERO";
SET AUTOCOMMIT = 0;
START TRANSACTION;
SET time_zone = "+00:00";


/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8mb4 */;

--
-- База данных: `stud13_HABR`
--

-- --------------------------------------------------------

--
-- Структура таблицы `Hub`
--

CREATE TABLE `Hub` (
  `HubId` int(11) NOT NULL,
  `Name` varchar(70) NOT NULL,
  `Description` varchar(200) NOT NULL,
  `Image` varchar(100) NOT NULL
) ENGINE=MyISAM DEFAULT CHARSET=utf8;

--
-- Дамп данных таблицы `Hub`
--

INSERT INTO `Hub` (`HubId`, `Name`, `Description`, `Image`) VALUES
(1, 'ШИндовсcc', 'ывывфывыфафыаыф', 'hub1.jpg'),
(2, 'ПорнХАбр', 'Самые горячие коды', 'hub2.jpg'),
(3, 'sdsds', 'eqiwufiudaigfagfduiayfgf', 'hub3.jpg'),
(4, 'Витина креативность', 'Отсутствует', 'hub4.png'),
(5, 'Последний тестовый, наверное', 'Ну если мне 5 не хватит, доваблю ещё', 'hub5.jpg');

-- --------------------------------------------------------

--
-- Структура таблицы `HubPost`
--

CREATE TABLE `HubPost` (
  `HubPostId` int(11) NOT NULL,
  `HubId` int(11) NOT NULL,
  `PostId` int(11) NOT NULL
) ENGINE=MyISAM DEFAULT CHARSET=utf8;

--
-- Дамп данных таблицы `HubPost`
--

INSERT INTO `HubPost` (`HubPostId`, `HubId`, `PostId`) VALUES
(26, 3, 12),
(25, 2, 12),
(3, 4, 5),
(4, 4, 6),
(5, 5, 6),
(6, 5, 7),
(7, 3, 7),
(8, 5, 8),
(9, 3, 8),
(24, 5, 2),
(23, 4, 2);

-- --------------------------------------------------------

--
-- Структура таблицы `HubUser`
--

CREATE TABLE `HubUser` (
  `HubUserId` int(11) NOT NULL,
  `HubId` int(11) NOT NULL,
  `UserId` int(11) NOT NULL
) ENGINE=MyISAM DEFAULT CHARSET=utf8;

--
-- Дамп данных таблицы `HubUser`
--

INSERT INTO `HubUser` (`HubUserId`, `HubId`, `UserId`) VALUES
(1, 4, 2),
(2, 3, 1),
(3, 2, 2),
(4, 1, 3),
(11, 5, 9),
(6, 1, 1),
(7, 4, 3),
(10, 2, 9);

-- --------------------------------------------------------

--
-- Структура таблицы `Posts`
--

CREATE TABLE `Posts` (
  `PostId` int(11) NOT NULL,
  `UserId` int(11) NOT NULL,
  `Content` longtext NOT NULL,
  `Title` varchar(200) NOT NULL,
  `Date` datetime NOT NULL,
  `ShortContent` longtext NOT NULL,
  `Image` varchar(100) DEFAULT NULL,
  `IsNews` tinyint(1) NOT NULL
) ENGINE=MyISAM DEFAULT CHARSET=utf8;

--
-- Дамп данных таблицы `Posts`
--

INSERT INTO `Posts` (`PostId`, `UserId`, `Content`, `Title`, `Date`, `ShortContent`, `Image`, `IsNews`) VALUES
(12, 1, '<div class=\"article-formatted-body article-formatted-body article-formatted-body_version-2\">Сегодня, известный на весь мир душевно больных студент, по имени Тимур сидит с 8:30 и не может дописать прогу</div>', 'Тимур не может дописать приложение', '2022-05-19 12:55:54', '<div class=\"article-formatted-body article-formatted-body article-formatted-body_version-2\">Сегодня, известный на весь мир душевно больных студент, по имени Тимур сидит с 8:30 и не может дописать прогу</div>', NULL, 0),
(2, 2, '<div class=\"article-formatted-body article-formatted-body article-formatted-body_version-2\"><div xmlns=\"http://www.w3.org/1999/xhtml\"><blockquote><p>Если вы считаете, что делать глобальные продукты просто, вы никогда не настраивали робот-пылесос Xiaomi.</p></blockquote><p>Глобальные продукты делать сложно. Везде свои особенности, свой рынок. И любой продукт должен хорошо работать на каждом из них.</p><h4>Коротко про наш бизнес и вопросы, которые стояли перед IT-командой</h4><p>Мы строим QSR (<em>англ.</em> quick service restaurant — рестораны быстрого обслуживания) и расширяемся с помощью франчайзинга. В основе бизнеса лежит <a href=\"https://habr.com/ru/company/dododev/blog/506136/\">Dodo IS</a> – система, через которую проходят все процессы, от приёма заказа до управления поставками ингредиентов.</p><p>Сейчас Dodo IS работает в 16 странах и для 3 концепций (пиццерии, кофейни и донерные). Наша стратегия — постоянное открытие новых стран, развитие мастер-франчайзинга (т.е. когда приходит партнёр, открывает несколько пиццерий в стране и затем сам начинает франчайзинг привлекать в этой стране). Мы должны быть готовы к такому росту, к постоянному подключению новых стран. 60 стран, 100 стран. Более чем реально.</p><p>Сегодня у нас 3 бренда, но уже понятно, что их может быть и 5, и 10 и 20. Не сейчас, но они будут — новые концепции со своими особенностями.</p><p>И как тогда обеспечивать вариативность системы и её поддержку? Как масштабировать без найма 100500 дополнительных разработчиков? Как определить, в какую часть Dodo IS инвестировать больше, а какую поставить на паузу? А как вообще открывать новые страны, там ведь везде свои законы и особенности? Ответы на эти вопросы нужно было искать как можно скорее.</p><p>Кроме этого, все запросы на доработки прилетали в нашу большую IT-команду. И каждый раз приходилось решать:</p><p><em>«А что важнее? Запустить программу лояльности в Эстонии или сторис в приложении для Евразии?»</em></p><p><em>«А что важнее? Сделать централизованное управление меню или кастомный трекинг?»</em></p><p><em>«А что важнее? Интеграция с агрегаторами или платная доставка?»</em></p><p>Эти вопросы кажутся странными, несравнимыми, но в то же время они вполне логичны, ведь в условиях ограничений приходится делать выбор, причём выбор на абсолютно разных уровнях.</p><blockquote><p>Как думаете, кто должен давать ответы на такие вопросы? Кто должен выбирать? Бизнес-команда конкретного рынка, CPO или CEO компании?</p></blockquote><p>Расскажу, как было у нас. За последние 5 лет мы прошли много трансформаций. Работали в едином темпе (общий старт итераций, у всех спринт 2 недели), экспериментировали с LeSS и управляли Dodo IS под все страны как единым продуктом, делили его и делали LeSS Huge, оставляя на уровне команд относительную свободу.</p><p>Но всегда, на протяжении последних лет была одна общая черта, которая не работала. Все запросы стекались в IT-команду и как-то разруливались на уровне CPO или владельца конкретного продукта. Вроде звучит логично и просто, но на деле наши бизнес-команды (а они работают на конкретном рынке) сталкивались с тем, что не знали, будем мы работать над вот этими задачами бизнеса дальше или нет. Продакт и CPO вынуждены были постоянно балансировать между рынками и пытаться встроить в бэклог задачи, нужные всем рынкам, да ещё и о поддержке не забыть.</p><p>Такая система при масштабе давала всё больше сбоев, напряжённых отношений и фактического разделения на IT и бизнес.</p><blockquote><p>Нам нужна была новая структура. Но не такая, чтобы умело находить ответы на эти вопросы и ловко жонглировать приоритетами. Нам нужно было придумать её такой, чтобы этих вопросов не существовало в принципе.&nbsp;</p></blockquote><p>И мы попробовали её создать. В основу легла концепция рыночных и глобальных команд с очень простым и понятным разделением ответственности.</p><p><strong>Рыночные команды</strong> делают продукты и меняют Dodo IS, исходя из приоритетов конкретного рынка. Они делают решения максимально быстро, главное для них — скорость адаптации к рынку. Универсальность команд — их ключевая компетенция, они могут залезть в любую часть Dodo IS. Рыночные команды отвечают только за поддержку специализированных рыночных решений.</p><p><em>Так появились рыночные команды новых концепций Донер 42, Дринкит; новых перспективных рынков UK и международного; несколько команд Пиццы Евразии.</em></p><p><strong>Глобальные команды</strong> делают продукты и меняют Dodo IS для всех стран и брендов, их приоритеты драйвятся глобальными целями Dodo Brands, а именно <a href=\"https://dodobrands.io/ru/post/plan333/\">Планом 333</a>. Они делают решения максимально гибкими, адаптируемыми и надёжными. Они преимущественно работают над своими компонентами.</p><p><em>Это команды производства, учёта, CVM (лояльность + клиентский профиль), Data, SRE и другие.</em></p><h3>Взаимодействие рыночных и глобальных команд</h3><p>Последние несколько лет я много изучал, как работает IT в других франчайзинговых сетях. И там есть одна особенность, которая очень сильно сдерживает развитие. У них нет глобальной части. У них только локально рыночные решения под страну, регион или несколько регионов. И если мастер-франчайзи региона построил сильное локальное IT, сделал какие-то решения, которые будут полезны всему бренду глобально, могут уйти годы на то, чтобы продать эти решения наверх. И не факт, что получится продать. Эта модель предполагает очень большой состав локальных рыночных команд (пусть и сгруппированных по регионам).</p><p>Наша структура и процессы дают возможность тиражировать решения от рынка в глобал и от глобала к рынку. В обоих направлениях. Если рыночная команда сделала фичу, которая может быть полезна всем – круто, глобальная команда может адаптировать или другая рыночная команда заберёт себе и подстроит под себя. Или рыночная команда может сразу сделать решение доступным для остальных, просто отдав в глобальную команду поддержку.</p><p>Глобальная команда сделала новую систему лояльности – супер, рыночные команды имеют полный доступ к решению и могут адаптировать его у себя.</p><p>Получается двустороннее взаимодействие, которое максимизирует и возможности для рынков использовать готовые инструменты, и приводит к тому, что глобальные команды могут интегрировать прорывные рыночные решения, которые уже протестированы.</p><p>Сейчас эта модель предполагает большую глобальную команду платформы Dodo IS и небольшие рыночные команды, хотя на горизонте 5-10 лет, с открытием новых рынков, этот баланс изменится.</p><h3>В основе взаимодействия — общий код</h3><p>Всё это не работало бы без одной важной составляющей. Общий код, доступный всем командам без исключения. Любой код может поменять абсолютно любой человек в Dodo Engineering — неважно, из какой он команды.</p><p>Есть такой подход, называется<a href=\"https://resources.github.com/whitepapers/introduction-to-innersource/\"> InnerSource</a>. Это как Open Source, работающий внутри одной компании. Все принципы Open Source разработки, полностью открытый код, есть владельцы компонентов, отвечающие долгосрочно за его стабильность и развитие, и любой человек из компании может контрибьютить в него, пройдя ревью или любые другие правила, заданные владельцами. Баланс между скоростью рынков и стабильностью глобальных продуктов.</p><p>InnerSource не бесплатен. Его эффективность прямо зависит от вложений в инженерку, тесты, в качество глобальных продуктов, которые будут менять десятки команд. Если не автоматизирован регресс и он занимает пару дней, можно забыть о быстрых изменениях. Вот вроде бы банальная мысль, но без неё на практике ничего не заработает: рыночная команда будет вставать в виртуальную очередь, чтобы внести свои изменения, протестировать их, споткнуться на том что компонент-то не наш, нужна помощь ещё тестировщика из команды-овнера, а он недоступен, короче, дичь. Еще в 2017 году мы начали активно вкладываться в инженерные практики и вот сейчас эти вложения окупаются, оказывая прямое влияние на бизнес.</p><h3>Как такая структура работает в реальности</h3><p>Разберу очень простой реальный пример, иллюстрирующий работу. У нас есть рыночная команда Донер 42, задача которой – развивать свой продукт. И этому продукту потребовалось сделать платную доставку.</p><p>С одной стороны, ребята могли пойти к одной из глобальных команд, занимающейся доставкой или core-частью приёма заказа и договориться, чтобы для них сделали функцию платной доставки.</p><p>И если бы у них не было доступа к коду, так бы им и пришлось сделать, либо костылять что-то, не связанное с системой на своей стороне.</p><p>Но InnerSource даёт возможность сделать иначе. Ребята идут в core-компоненты доставки или приёма заказа и спокойно встраивают туда функцию платной доставки самостоятельно, де-факто открывая возможность использовать эту фичу командам других рынков. У них нет цели делать универсальные решения, у них нет цели сделать решение для других — они решают свою задачу.</p><p>На следующем этапе развития глобальная команда заберёт себе на поддержку функционал по платной доставке, допилит его где надо и будет полностью отвечать за его работоспособность.</p><h3>Какие команды отвечают за поддержку</h3><p>Поддержка и обеспечение SLA для сервисов зависит от того, что это за решение – рыночное или глобальное. К примеру, мобильное приложение Донер 42 целиком принадлежит рынку Донера, соответственно, API и мобила в их владении и обеспечение работы 24/7 ложится на плечи рыночных команд.&nbsp;</p><p>Если рыночная команда делает изменение, например, в трекере, т.е. в глобальном продукте, поддержка этого решения остаётся на глобальной команде. Таким образом глобальные команды самостоятельно устанавливают правила, как к ним можно приносить изменения, Pull Requests, требования к ним, прогон тестов, что-то ещё. Обеспечение работы 24/7 — на глобальных командах.</p><details class=\"spoiler\"><summary>Что изменилось весной 22-го</summary><div class=\"spoiler__content\"><p>В условиях новой реальности у нас 2 ключевые цели:</p><ul><li><p>сохранить бизнес, чтобы развиваться в будущем;</p></li><li><p>избежать сокращений.</p></li></ul><p>У нас, как у любой растущей компании, есть стабильное направление (бизнес в Евразии) и инвестиционные проекты для роста. Часть проектов для роста мы остановили, сфокусировались на Евразии, по сути — на задаче сохранения бизнеса. На этом сосредоточили максимум усилий.</p><p>Чтобы сохранить бизнес, нам нужно было справиться со следующими вызовами:</p><ol><li><p>Пережить значительное увеличение цен на ингредиенты.</p></li><li><p>Решить проблемы с оплатами (отключение карт, Apple Pay, DDoS-атаки на платежные сервисы).</p></li><li><p>Увеличить выручку рынка Евразии.</p></li><li><p>Переехать на локальные сервера.</p></li></ol><p>Всё, что нам нужно было сделать — остановить часть глобальных целей и перевести ребят на задачи Евразии. Поскольку рыночные команды уже были тесно интегрированы с бизнес-командами, это выглядело просто как расширение и помощь, без каких-либо серьёзных перетрясок, новых продуктов, прояснений того, что делать надо, а что нет. Общий код помог сделать этот переход вообще незаметным. Я даже ловлю себя на мысли что такая реакция и преобразования прошли как-то уж слишком гладко. Но это так!</p></div></details><h3>Год прошёл, полёт нормальный</h3><p>Такая структура с глобальными и рыночными командами – это не моё изобретение, не что-то сверхновое, это очень простое и логичное решение. Для нас оно выглядит сейчас слишком очевидным. Процесс перестройки и адаптации занял почти год. Эффект позитивный, неоднозначные вопросы исчезли, каждый продукт имеет свои цели, при этом пересечений много, все друг о друге знают и не скатываются в ситуацию, когда две команды делают одно и то же. И при необходимости легко перестраиваются, кризис это показал.</p><p>Эта модель позволяет нам масштабироваться. Сегодня у нас 16 стран и 5 рыночных команд. Рынки будут расти и стран станет 60, а рыночных команд — 15 или 20, при этом все они продолжат работать по тем же принципам: рынки — для скорости, глобал — для гибкости, общий код — для всех.</p><p></p></div></div>', 'Глобальные попуски, и что они вызывают', '2022-04-05 11:38:43', '<div class=\"article-formatted-body article-formatted-body article-formatted-body_version-2\"><p>Перед компаниями, которые делают глобальные продукты или создают сервисы для разных стран, постоянно возникают вопросы приоритетов и масштабирования. Иногда это приводит к тому, что ресурсы используются неэффективно и разные команды работают над одной и той же фичей для разных продуктов.<br><br>В этой статье расскажу, на какие вопросы приходилось отвечать нашей IT-команде, какие проблемы они вызывали и как сейчас удаётся их решать с помощью новой структуры и подхода InnerSource.</p><p></p></div>', 'pic1.png', 0),
(3, 2, '<div class=\"article-formatted-body article-formatted-body article-formatted-body_version-2\"><div xmlns=\"http://www.w3.org/1999/xhtml\"><p>Будучи .NET разработчиком, я стараюсь периодически просматривать различные ресурсы, связанные с .NET тематикой. Как правило, это различные блоги. Иногда то тут, то там появляются какие-нибудь интересные статьи, на которые стоит обратить внимание.</p><p>Недавно я поймал себя на мысли, что делать это вручную мне как-то поднадоело. Тем более, что просматриваю я обычно одни и те же сайты. А значит время заняться автоматизацией.</p><p>Идея была достаточно проста. Нужен скрипт, который сходит по разным ссылкам, разберёт содержимое и отправит обновление в какой-нибудь telegram-канал. Нужно было только придумать, как этот скрипт запускать и где сохранять результат его работы, чтобы знать, что уже было отправлено, а что нет.</p><p>Я решил использовать в качестве хранилища GitHub, а сам скрипт (написан на TypeScript) запускать по расписанию с помощью GitHub Actions. В этой статье я хочу рассказать про некоторые технические детали реализации и поделиться полученным результатом.</p><h2>Основная логика GitHub Action</h2><p>За основу проекта я взял минимальный GitHub Action, который описывал в <a href=\"https://habr.com/ru/post/561644/\" rel=\"noopener noreferrer nofollow\">этой статье</a>, и исходный код которого можно найти <a href=\"https://github.com/Chakrygin/hello-github-action\" rel=\"noopener noreferrer nofollow\">тут</a>.</p><p>Точкой входа в проект является функция main, которая (упрощённо) выглядит следующим образом:</p><pre><code class=\"javascript hljs\"><span class=\"hljs-keyword\">import</span> * <span class=\"hljs-keyword\">as</span> core <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\'@actions/core\'</span>;\r\n<span class=\"hljs-keyword\">import</span> * <span class=\"hljs-keyword\">as</span> github <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\'@actions/github\'</span>;\r\n\r\n<span class=\"hljs-comment\">// Other imports...</span>\r\n\r\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">main</span>(<span class=\"hljs-params\"></span>) </span>{\r\n  <span class=\"hljs-keyword\">try</span> {\r\n\r\n    <span class=\"hljs-keyword\">const</span> scrapers: Scraper[] = [\r\n      <span class=\"hljs-keyword\">new</span> AndrewLockScraper(),\r\n      <span class=\"hljs-keyword\">new</span> DevBlogsScraper(<span class=\"hljs-string\">\'dotnet\'</span>),\r\n      <span class=\"hljs-keyword\">new</span> DevBlogsScraper(<span class=\"hljs-string\">\'nuget\'</span>),\r\n      <span class=\"hljs-keyword\">new</span> DevBlogsScraper(<span class=\"hljs-string\">\'visualstudio\'</span>),\r\n      <span class=\"hljs-keyword\">new</span> HabrScraper(),\r\n      <span class=\"hljs-keyword\">new</span> JetBrainsScraper(<span class=\"hljs-string\">\'how-tos\'</span>),\r\n      <span class=\"hljs-keyword\">new</span> JetBrainsScraper(<span class=\"hljs-string\">\'releases\'</span>),\r\n      <span class=\"hljs-keyword\">new</span> JetBrainsScraper(<span class=\"hljs-string\">\'net-annotated\'</span>),\r\n    ];\r\n\r\n    <span class=\"hljs-keyword\">const</span> IS_PRODUCTION = github.context.ref === <span class=\"hljs-string\">\'refs/heads/main\'</span>;\r\n\r\n    <span class=\"hljs-keyword\">const</span> TELEGRAM_TOKEN = getInput(<span class=\"hljs-string\">\'TELEGRAM_TOKEN\'</span>);\r\n    <span class=\"hljs-keyword\">const</span> TELEGRAM_PUBLIC_CHAT_ID = getInput(<span class=\"hljs-string\">\'TELEGRAM_PUBLIC_CHAT_ID\'</span>);\r\n    <span class=\"hljs-keyword\">const</span> TELEGRAM_PRIVATE_CHAT_ID = getInput(<span class=\"hljs-string\">\'TELEGRAM_PRIVATE_CHAT_ID\'</span>);\r\n\r\n    <span class=\"hljs-keyword\">const</span> publicSender = <span class=\"hljs-keyword\">new</span> TelegramSender(TELEGRAM_TOKEN, TELEGRAM_PUBLIC_CHAT_ID);\r\n    <span class=\"hljs-keyword\">const</span> privateSender = <span class=\"hljs-keyword\">new</span> TelegramSender(TELEGRAM_TOKEN, TELEGRAM_PRIVATE_CHAT_ID);\r\n\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> scraper <span class=\"hljs-keyword\">of</span> scrapers) {\r\n      <span class=\"hljs-keyword\">await</span> core.group(scraper.name, <span class=\"hljs-keyword\">async</span> () =&gt; {\r\n\r\n        <span class=\"hljs-keyword\">const</span> storage = <span class=\"hljs-keyword\">new</span> Storage(scraper.path);\r\n        <span class=\"hljs-keyword\">const</span> sender = IS_PRODUCTION &amp;&amp; storage.exists() ? publicSender : privateSender;\r\n\r\n        <span class=\"hljs-keyword\">try</span> {\r\n          <span class=\"hljs-keyword\">await</span> scraper.scrape(storage, sender);\r\n        }\r\n        <span class=\"hljs-keyword\">catch</span> (error: any) {\r\n          core.error(error, { <span class=\"hljs-attr\">title</span>: <span class=\"hljs-string\">`The \'<span class=\"hljs-subst\">${scraper.name}</span>\' scraper has failed.`</span> });\r\n        }\r\n        <span class=\"hljs-keyword\">finally</span> {\r\n          storage.save();\r\n        }\r\n\r\n      });\r\n    }\r\n\r\n  }\r\n  <span class=\"hljs-keyword\">catch</span> (error: any) {\r\n    core.setFailed(error);\r\n  }\r\n}</code></pre><p>Здесь используются три типа сущностей:</p><ul><li><p>Scraper - интерфейс, отвечающий за парсинг различных источников. Он имеет несколько реализаций для каждого конкретного сайта с соответствующим набором костылей (например для <a href=\"http://andrewlock.net\" rel=\"noopener noreferrer nofollow\">andrewlock.net</a> или <a href=\"http://devblogs.microsoft.com\" rel=\"noopener noreferrer nofollow\">devblogs.microsoft.com</a>).</p></li><li><p>Sender - класс, отвечающий за отправку сообщений в Telegram.</p></li><li><p>Storage - класс отвечающий за сохранение ссылок на отправленные сообщения в файлы, чтобы при каждом новом запуске отправлять в Telegram только новые сообщения.</p></li></ul><p>Общая логика тут довольна проста. Все реализации Scraper перебираются в цикле и парсят соответствующий сайт. Каждый Scraper получает в качестве параметров ссылки на Storage, чтобы знать, куда сохранить результат своей работы и Sender, чтобы отправить новые посты (которых ещё нет в Storage) в Telegram.</p><p>Чтобы запускать скрипт из GitHub я добавил в репозиторий файл рабочего процесса <code>.github/workflows/scrape.yml</code>:</p><pre><code class=\"yaml hljs\"><span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">Scrape</span>\r\n\r\n<span class=\"hljs-attr\">on:</span>\r\n  <span class=\"hljs-attr\">push:</span>\r\n    <span class=\"hljs-attr\">paths:</span>\r\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">dist/index.js</span>\r\n  <span class=\"hljs-attr\">schedule:</span>\r\n    <span class=\"hljs-comment\"># At minute 42 past every 2nd hour.</span>\r\n    <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">cron:</span> <span class=\"hljs-number\">42</span> <span class=\"hljs-string\">*/2</span> <span class=\"hljs-string\">*</span> <span class=\"hljs-string\">*</span> <span class=\"hljs-string\">*</span>\r\n\r\n<span class=\"hljs-attr\">jobs:</span>\r\n  <span class=\"hljs-attr\">Scrape:</span>\r\n    <span class=\"hljs-attr\">runs-on:</span> <span class=\"hljs-string\">ubuntu-latest</span>\r\n\r\n    <span class=\"hljs-attr\">steps:</span>\r\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">Checkout</span>\r\n        <span class=\"hljs-attr\">uses:</span> <span class=\"hljs-string\">actions/checkout@v2</span>\r\n\r\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">Scrape</span>\r\n        <span class=\"hljs-attr\">uses:</span> <span class=\"hljs-string\">./</span>\r\n        <span class=\"hljs-attr\">with:</span>\r\n          <span class=\"hljs-attr\">TELEGRAM_TOKEN:</span> <span class=\"hljs-string\">${{</span> <span class=\"hljs-string\">secrets.TELEGRAM_TOKEN</span> <span class=\"hljs-string\">}}</span>\r\n          <span class=\"hljs-attr\">TELEGRAM_PUBLIC_CHAT_ID:</span> <span class=\"hljs-string\">${{</span> <span class=\"hljs-string\">secrets.TELEGRAM_PUBLIC_CHAT_ID</span> <span class=\"hljs-string\">}}</span>\r\n          <span class=\"hljs-attr\">TELEGRAM_PRIVATE_CHAT_ID:</span> <span class=\"hljs-string\">${{</span> <span class=\"hljs-string\">secrets.TELEGRAM_PRIVATE_CHAT_ID</span> <span class=\"hljs-string\">}}</span></code></pre><p>Тут я добавил два триггера:</p><ul><li><p>push - перезапускает скрипт при каждом пуше, который изменяет файл dist/index.js. (Это файл скрипта, собранный в githook через <code>@vercel/ncc</code>, который фактически запускается в GitHub. Для чего это нужно можно подробнее прочитать в <a href=\"https://habr.com/ru/post/561644/\" rel=\"noopener noreferrer nofollow\">этой статье</a>)</p></li><li><p>schedule - запускает скрипт по расписанию в 42 минуту каждого второго часа. Тут стоит отметить, что GitHub не строго гарантирует запуск в это время. Он может опаздывать, и иногда задержка может составлять до 20-30 минут.</p></li></ul><p>Сам рабочий процесс состоит из трёх шагов:</p><ul><li><p>Checkout - выкачивает исходники репозитория в рабочую директорию.</p></li><li><p>Scrape - собственно сам процесс запуска GitHub Action, который находится в корне этого же репозитория (ссылка <code>uses: ./</code>).</p></li><li><p>Про третий шаг я расскажу чуть позже.</p></li></ul><h2>Немного про логирование</h2><p>Здесь я хочу немного отклониться и поговорить про логирование. В целом, никто не мешает писать логи обычным <code>console.log</code>, но для GitHub Actions есть более удобный способ.</p><p>Существует набор полезных npm пакетов для разработки, который называется <a href=\"https://github.com/actions/toolkit\" rel=\"noopener noreferrer nofollow\">GitHub Actions Toolkit</a>. В него в частности входит пакет <code>@actions/core</code>, в котором есть набор полезных функций для логирования.</p><p>Во-первых, для улучшения читабельности длинных логов можно группировать их при помощи функции <code>core.group</code>, достаточно просто обернуть кусок кода в вызов этой функции:</p><pre><code class=\"javascript hljs\">core.group(<span class=\"hljs-string\">\'Some group name\'</span>, <span class=\"hljs-keyword\">async</span> () =&gt; {\r\n  <span class=\"hljs-comment\">// ...</span>\r\n  core.info(<span class=\"hljs-string\">\'Some message in group.\'</span>);\r\n  <span class=\"hljs-comment\">// ...</span>\r\n});</code></pre><p>У меня в логах это выглядит следующим образом:</p><figure class=\"full-width \"><img src=\"https://habrastorage.org/getpro/habr/upload_files/0c8/b5b/98d/0c8b5b98d0a1007371a535aaa31e41d6.PNG\" width=\"2691\" height=\"1483\"><figcaption></figcaption></figure><p>Во-вторых, искать в логах все сообщения об ошибках может быть немного утомительно, однако если если для логирования используются функции <code>core.error</code>, <code>core.warning</code> или <code>core.notice</code>, то все такие сообщения будут выведены на главную страницу рабочего процесса в виде аннотаций и будут сразу бросаться в глаза.</p><p>Кроме этого вместе с сообщением, которое просто выводится в лог, можно также задать заголовок для аннотации (и даже ссылки на место в файле, где случилась ошибка, если это необходимо). </p><p>Выглядят аннотации в интерфейсе следующим образом:</p><figure class=\"full-width \"><img src=\"https://habrastorage.org/getpro/habr/upload_files/741/c77/2d8/741c772d84fb949fc7c5fbadef0fcfd2.PNG\" width=\"2697\" height=\"1705\"><figcaption></figcaption></figure><h2>Реализация Storage и сохранение результатов работы в файлы</h2><p>Поскольку я планировал сохранять результаты работы в git репозиторий, проще всего было хранить их в виде обычных текстовых файлов.</p><p>Я решил, что каждая реализация Scraper будет иметь собственную папку в репозитории, и дополнительно сделал разбивку по месяцам (чтобы в перспективе можно было автоматически удалять старые файлы). В итоге у меня получилась такая структура файлов:</p><figure class=\"full-width \"><img src=\"https://habrastorage.org/getpro/habr/upload_files/f31/fa2/56f/f31fa256fb5c652c65d0b76da749df0f.PNG\" width=\"2966\" height=\"1756\"><figcaption></figcaption></figure><p>Каждый раз, когда какой либо Scraper отправляет сообщение в Telegram, он дописывает ссылку в соответствующий файл. После того, как все Scraper отработали, остаётся только сохранить изменённые файлы в репозиторий. Сделать это можно несколькими способами.</p><p>Можно воспользоваться пакетом <code>@actions/exec</code> (<a href=\"https://github.com/actions/toolkit/tree/main/packages/core\" rel=\"noopener noreferrer nofollow\">ссылка</a>) и просто вызвать из кода команды <code>git add</code>, <code>git commit</code> и <code>git push</code>. Этот способ также потребует сначала вызвать <code>git config</code>, чтобы указать имя пользователя и эл. почту (можно использовать специальную почту <code>&lt;UserName&gt;@users.noreply.github.com</code>, которая есть у всех пользователей GitHub).</p><p>Я же решил воспользоваться готовым решением и использовать GitHub Action из Marketplace: <a href=\"https://github.com/marketplace/actions/add-commit\" rel=\"noopener noreferrer nofollow\">Add &amp; Commit</a>. Это третий шаг пайплайна, который используется следующим образом:</p><pre><code class=\"yaml hljs\"><span class=\"hljs-attr\">steps:</span>\r\n  <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">Checkout</span>\r\n    <span class=\"hljs-attr\">uses:</span> <span class=\"hljs-string\">actions/checkout@v2</span>\r\n\r\n  <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">Scrape</span>\r\n    <span class=\"hljs-attr\">uses:</span> <span class=\"hljs-string\">./</span>\r\n    <span class=\"hljs-attr\">with:</span>\r\n      <span class=\"hljs-attr\">TELEGRAM_TOKEN:</span> <span class=\"hljs-string\">${{</span> <span class=\"hljs-string\">secrets.TELEGRAM_TOKEN</span> <span class=\"hljs-string\">}}</span>\r\n      <span class=\"hljs-attr\">TELEGRAM_PUBLIC_CHAT_ID:</span> <span class=\"hljs-string\">${{</span> <span class=\"hljs-string\">secrets.TELEGRAM_PUBLIC_CHAT_ID</span> <span class=\"hljs-string\">}}</span>\r\n      <span class=\"hljs-attr\">TELEGRAM_PRIVATE_CHAT_ID:</span> <span class=\"hljs-string\">${{</span> <span class=\"hljs-string\">secrets.TELEGRAM_PRIVATE_CHAT_ID</span> <span class=\"hljs-string\">}}</span>\r\n\r\n  <span class=\"hljs-comment\"># https://github.com/marketplace/actions/add-commit</span>\r\n  <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">Commit</span>\r\n    <span class=\"hljs-attr\">uses:</span> <span class=\"hljs-string\">EndBug/add-and-commit@v9.0.0</span>\r\n    <span class=\"hljs-attr\">if:</span> <span class=\"hljs-string\">${{</span> <span class=\"hljs-string\">always()</span> <span class=\"hljs-string\">&amp;&amp;</span> <span class=\"hljs-string\">github.ref</span> <span class=\"hljs-string\">==</span> <span class=\"hljs-string\">\'refs/heads/main\'</span> <span class=\"hljs-string\">}}</span>\r\n    <span class=\"hljs-attr\">with:</span>\r\n      <span class=\"hljs-attr\">add:</span> <span class=\"hljs-string\">data</span>\r\n      <span class=\"hljs-attr\">message:</span> <span class=\"hljs-string\">Commit</span> <span class=\"hljs-string\">scrape</span> <span class=\"hljs-string\">results</span></code></pre><p>Этот шаг просто проверяет, есть ли какие-нибудь незакомиченные изменения в указанной папке (в моём случае это папка <code>data</code>) и, если они есть, делает коммит с указанным сообщением.</p><p>Я также добавил дополнительное условие запуска на ветку <code>main</code> (т.к. запуски из других веток отправляют сообщения в приватный канал, который я использую для отладки, и их не нужно коммитить). А также условие <code>always()</code>, чтобы коммит происходил даже в том случае, если предыдущий шаг упал (т.к. он всё же мог что-то отправить и записать в файлы).</p><h2>Реализация Sender и отправка сообщений в Telegram</h2><p>Для отправки сообщений в Telegram я решил воспользоваться готовым клиентом из пакета <a href=\"https://github.com/telegraf/telegraf\" rel=\"noopener noreferrer nofollow\">telegraf</a>. Пользоваться им достаточно просто. Достаточно создать экземпляр класса <a href=\"https://telegraf.js.org/classes/Telegram.html\" rel=\"noopener noreferrer nofollow\">Telegram</a> и можно отправлять сообщения. Но для этого сначала необходимо получить два параметра: <code>token</code> и <code>chatId</code>.</p><p>Все сообщения отправляются в Telegram от имени бота. Чтобы его создать необходимо воспользоваться другим ботом <a href=\"https://telegram.me/BotFather\" rel=\"noopener noreferrer nofollow\">BotFather</a>, который задаст несколько вопросов и в конце выдаст токен.</p><p>Параметр <code>chatId</code> определяет в какой чат бот будет отправлять сообщения. С этим параметром всё несколько сложнее:</p><ul><li><p>Для публичных каналов можно просто использовать имя канала.</p></li><li><p>Если канал приватный, то <code>chatId</code> - это некоторый отрицательный числовой идентификатор. Его можно узнать через бота <a href=\"https://telegram.me/username_to_id_bot\" rel=\"noopener noreferrer nofollow\">IDBot</a>. Для этого ему нужно отправить инвайт в этот приватный канал и в ответ получить идентификатор чата.</p></li><li><p>Также можно отправлять сообщения от имени бота самому себе (в чат с ботом). Чтобы узнать идентификатор этого чата нужно сначала отправить какое-нибудь сообщение боту, а затем перейти по ссылке: <code>https://api.telegram.org/bot&lt;BotToken&gt;/getUpdates</code>. В полученном json можно будет найти параметр <code>chatId</code>.</p></li></ul><p>Последний способ я использовал, чтобы отправлять себе сообщения об ошибках, чтобы иметь возможность быстро на них реагировать.</p><p>Все переменные я указал в настройках проекта на GitHub в разделе Secrets, и они передаются в GitHub Action через параметры в файле рабочего процесса:</p><figure class=\"full-width \"><img src=\"https://habrastorage.org/getpro/habr/upload_files/f7d/74c/56d/f7d74c56d1ee9967317e89d7ad0fe9b9.PNG\" width=\"2339\" height=\"937\"><figcaption></figcaption></figure><p>Мне также хотелось, чтобы сообщения в канале выглядели более или менее симпатично, поэтому для форматирования я использовал html, который Telegram <a href=\"https://core.telegram.org/api/entities\" rel=\"noopener noreferrer nofollow\">поддерживает в очень ограниченном виде</a>, а также при реализации Scraper добавил логику поиска картинок на сайтах. В итоге код отправки сообщений у меня выглядит следующим образом:</p><pre><code class=\"javascript hljs\"><span class=\"hljs-keyword\">async</span> send(message: Message): <span class=\"hljs-built_in\">Promise</span>&lt;<span class=\"hljs-keyword\">void</span>&gt; {\r\n  <span class=\"hljs-keyword\">const</span> messageHtml = getMessageHtml(message);\r\n\r\n  <span class=\"hljs-keyword\">if</span> (!message.image || messageHtml.length &gt; <span class=\"hljs-number\">1024</span>) {\r\n    <span class=\"hljs-keyword\">await</span> <span class=\"hljs-keyword\">this</span>.telegram.sendMessage(<span class=\"hljs-keyword\">this</span>.chatId, messageHtml, {\r\n      <span class=\"hljs-attr\">parse_mode</span>: <span class=\"hljs-string\">\'HTML\'</span>,\r\n    });\r\n  }\r\n  <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (message.image.endsWith(<span class=\"hljs-string\">\'.gif\'</span>)) {\r\n    <span class=\"hljs-keyword\">await</span> <span class=\"hljs-keyword\">this</span>.telegram.sendAnimation(<span class=\"hljs-keyword\">this</span>.chatId, message.image, {\r\n      <span class=\"hljs-attr\">caption</span>: messageHtml,\r\n      <span class=\"hljs-attr\">parse_mode</span>: <span class=\"hljs-string\">\'HTML\'</span>,\r\n    });\r\n  }\r\n  <span class=\"hljs-keyword\">else</span> {\r\n    <span class=\"hljs-keyword\">await</span> <span class=\"hljs-keyword\">this</span>.telegram.sendPhoto(<span class=\"hljs-keyword\">this</span>.chatId, message.image, {\r\n      <span class=\"hljs-attr\">caption</span>: messageHtml,\r\n      <span class=\"hljs-attr\">parse_mode</span>: <span class=\"hljs-string\">\'HTML\'</span>,\r\n    });\r\n  }\r\n}</code></pre><p>Тут нужно учесть, что если у сообщения есть картинка, то длина подписи к ней не может превышать 1024 символа, иначе Telegram вернёт ошибку. Поэтому длинные сообщения приходится отправлять просто через <code>sendMessage</code>.</p><p>При отправке gif, чтобы они нормально отображались, их следует отправлять как анимацию через <code>sendAnimation</code>. Все остальные картинки можно отправлять как фото через <code>sendPhoto</code>.</p><p>В итоге отформатированные сообщения в канале выглядят следующим образом:</p><figure class=\"full-width \"><img src=\"https://habrastorage.org/getpro/habr/upload_files/4cd/73f/074/4cd73f074d78b3ec4d0a7f514c2ea72b.PNG\" width=\"1477\" height=\"1458\"><figcaption></figcaption></figure><h2>Реализация Scraper и парсинг различных сайтов</h2><p>Как я уже упоминал, я сделал несколько реализаций Scraper для парсинга разных сайтов, но все они работают примерно по одному и тому же алгоритму:</p><pre><code class=\"javascript hljs\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AndrewLockScraper</span> <span class=\"hljs-title\">implements</span> <span class=\"hljs-title\">Scraper</span> </span>{\r\n  <span class=\"hljs-keyword\">async</span> scrape(storage: Storage, <span class=\"hljs-attr\">sender</span>: Sender): <span class=\"hljs-built_in\">Promise</span>&lt;<span class=\"hljs-keyword\">void</span>&gt; {\r\n    <span class=\"hljs-keyword\">for</span> <span class=\"hljs-keyword\">await</span> (<span class=\"hljs-keyword\">const</span> post <span class=\"hljs-keyword\">of</span> <span class=\"hljs-keyword\">this</span>.readPosts()) {\r\n      <span class=\"hljs-keyword\">if</span> (storage.has(post.href, post.date)) {\r\n        core.info(<span class=\"hljs-string\">\'Post already exists in storage. Break scraping.\'</span>);\r\n        <span class=\"hljs-keyword\">break</span>;\r\n      }\r\n\r\n      core.info(<span class=\"hljs-string\">\'Sending post...\'</span>);\r\n      <span class=\"hljs-keyword\">await</span> sender.send(post);\r\n\r\n      core.info(<span class=\"hljs-string\">\'Storing post...\'</span>);\r\n      storage.add(post.href, post.date);\r\n    }\r\n  }\r\n\r\n  private <span class=\"hljs-keyword\">async</span> *readPosts(): AsyncGenerator&lt;Message, <span class=\"hljs-keyword\">void</span>&gt; {\r\n    <span class=\"hljs-comment\">// ...</span>\r\n  }\r\n}</code></pre><p>Каждая реализация Scraper имеет метод с асинхронным генератором <code>readPosts</code>, который выполняет поиск новых постов и возвращает их по одному.</p><p>Ссылка каждого поста проверяется в хранилище и если пост уже там присутствует, то парсинг прекращается. Асинхронный генератор в данном случае позволяет не парсить все посты, учитывая, что обычно нужно проверить только один, самый последний и убедиться, что на сайте нет обновлений.</p><p>Если же пост оказался новым, он сначала отправляется в Telegram, а затем сохраняется в хранилище.</p><h3>Парсинг RSS</h3><p>Изначально для парсинга блогов я планировал по максимуму использовать RSS и, делая самую первую реализацию Scraper для сайта <a href=\"http://andrewlock.net\" rel=\"noopener noreferrer nofollow\">andrewlock.net</a>, использовал именно его.</p><p>Я использовал npm пакет <a href=\"https://github.com/rbren/rss-parser\" rel=\"noopener noreferrer nofollow\">rss-parser</a>, который неплохо справляется со своей задачей и даже умеет парсить кастомные поля, которые мне, кстати, понадобились. Работа с этим пакетом в общих чертах выглядит следующим образом:</p><pre><code class=\"javascript hljs\">private <span class=\"hljs-keyword\">async</span> *readPosts(): AsyncGenerator&lt;Message, <span class=\"hljs-keyword\">void</span>&gt; {\r\n  <span class=\"hljs-keyword\">const</span> parser = <span class=\"hljs-keyword\">new</span> RssParser({\r\n    <span class=\"hljs-attr\">customFields</span>: {\r\n      <span class=\"hljs-attr\">item</span>: [<span class=\"hljs-string\">\'media:content\'</span>, <span class=\"hljs-string\">\'media:content\'</span>, { <span class=\"hljs-attr\">keepArray</span>: <span class=\"hljs-literal\">true</span> }],\r\n    },\r\n  });\r\n\r\n  <span class=\"hljs-keyword\">const</span> feed = <span class=\"hljs-keyword\">await</span> parser.parseURL(<span class=\"hljs-string\">\'https://andrewlock.net/rss.xml\'</span>);\r\n\r\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> item <span class=\"hljs-keyword\">of</span> feed.items) {\r\n\r\n    <span class=\"hljs-keyword\">const</span> post: Message = {\r\n      <span class=\"hljs-comment\">// ...</span>\r\n    };\r\n\r\n    <span class=\"hljs-keyword\">yield</span> post;\r\n  }\r\n}</code></pre><h3>Парсинг HTML</h3><p>К сожалению, на этом вся радость использования RSS закончилась. Оказалось, что другие сайты хоть и имеют RSS фиды, но в них нет всей нужной мне информации: картинок, тегов, информации об авторах и т.п.</p><p>Поэтому дальше пришлось вооружиться npm пакетами <a href=\"https://github.com/axios/axios\" rel=\"noopener noreferrer nofollow\">axios</a> и <a href=\"https://github.com/cheeriojs/cheerio\" rel=\"noopener noreferrer nofollow\">cheerio</a>. Первый является http клиентом и позволяет скачать любую страницу в виде текста, а второй умеет парсить html и позволяет извлекать из него данные, используя запросы, похожие на селекторы jQuery.</p><p>Парсинг html страниц с использованием этих двух пакетов выглядит следующим образом:</p><pre><code class=\"javascript hljs\">private <span class=\"hljs-keyword\">async</span> *readPosts(): AsyncGenerator&lt;Message, <span class=\"hljs-keyword\">void</span>&gt; {\r\n  <span class=\"hljs-keyword\">const</span> response = <span class=\"hljs-keyword\">await</span> axios.get(<span class=\"hljs-string\">\'https://devblogs.microsoft.com/dotnet/\'</span>);\r\n  <span class=\"hljs-keyword\">const</span> $ = cheerio.load(response.data);\r\n  <span class=\"hljs-keyword\">const</span> entries = $(<span class=\"hljs-string\">\'#content .entry-box\'</span>).toArray();\r\n\r\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> index = <span class=\"hljs-number\">0</span>; index &lt; entries.length; index++) {\r\n    <span class=\"hljs-keyword\">const</span> entry = $(entries[index]);\r\n    <span class=\"hljs-keyword\">const</span> image = entry.find(<span class=\"hljs-string\">\'.entry-image img\'</span>).attr(<span class=\"hljs-string\">\'data-src\'</span>);\r\n    <span class=\"hljs-keyword\">const</span> title = entry.find(<span class=\"hljs-string\">\'.entry-title a\'</span>);\r\n    <span class=\"hljs-keyword\">const</span> author = entry.find(<span class=\"hljs-string\">\'.entry-author-link a\'</span>);\r\n    <span class=\"hljs-keyword\">const</span> date = entry.find(<span class=\"hljs-string\">\'.entry-post-date\'</span>).text();\r\n    <span class=\"hljs-keyword\">const</span> tags = entry.find(<span class=\"hljs-string\">\'.card-tags-links .card-tags-linkbox a\'</span>).toArray();\r\n\r\n    <span class=\"hljs-keyword\">const</span> post: Message = {\r\n      <span class=\"hljs-comment\">// ...</span>\r\n    };\r\n\r\n    <span class=\"hljs-keyword\">yield</span> post;\r\n  }\r\n}</code></pre><h2>Локальная отладка</h2><p>Последний, но важный момент на котором я хотел бы остановиться - это локальная отладка.</p><p>Как известно, для запуска кода на TypeScript его сначала нужно преобразовать в JavaScript, настроить Source Maps и возможно сделать ещё какую-то магию.</p><p>Я пользуюсь для разработки VS Code и у меня долго не получалось добиться простого запуска отладчика, который бы при этом нормально работал, по F5.</p><p>В итоге я наткнулся на npm пакет <a href=\"https://github.com/TypeStrong/ts-node\" rel=\"noopener noreferrer nofollow\">ts-node</a>, который умеет прятать всю эту магию с преобразованием из TypeScript в JavaScript под капот. Вместе с правильно настроенной конфигурацией в файле <code>launch.json</code> отладка по F5 работала без каких-либо проблем:</p><pre><code class=\"json hljs\">{\r\n  <span class=\"hljs-attr\">\"version\"</span>: <span class=\"hljs-string\">\"0.2.0\"</span>,\r\n  <span class=\"hljs-attr\">\"configurations\"</span>: [\r\n    {\r\n      <span class=\"hljs-attr\">\"type\"</span>: <span class=\"hljs-string\">\"pwa-node\"</span>,\r\n      <span class=\"hljs-attr\">\"request\"</span>: <span class=\"hljs-string\">\"launch\"</span>,\r\n      <span class=\"hljs-attr\">\"name\"</span>: <span class=\"hljs-string\">\"Launch Scrape\"</span>,\r\n      <span class=\"hljs-attr\">\"console\"</span>: <span class=\"hljs-string\">\"integratedTerminal\"</span>,\r\n      <span class=\"hljs-attr\">\"cwd\"</span>: <span class=\"hljs-string\">\"${workspaceFolder}\"</span>,\r\n      <span class=\"hljs-attr\">\"program\"</span>: <span class=\"hljs-string\">\"src/main.ts\"</span>,\r\n      <span class=\"hljs-attr\">\"envFile\"</span>: <span class=\"hljs-string\">\"${env:USERPROFILE}/${workspaceFolderBasename}.env\"</span>,\r\n      <span class=\"hljs-attr\">\"runtimeArgs\"</span>: [\r\n        <span class=\"hljs-string\">\"--nolazy\"</span>,\r\n        <span class=\"hljs-string\">\"-r\"</span>,\r\n        <span class=\"hljs-string\">\"./node_modules/ts-node/register\"</span>\r\n      ],\r\n      <span class=\"hljs-attr\">\"sourceMaps\"</span>: <span class=\"hljs-literal\">true</span>,\r\n      <span class=\"hljs-attr\">\"protocol\"</span>: <span class=\"hljs-string\">\"inspector\"</span>,\r\n      <span class=\"hljs-attr\">\"resolveSourceMapLocations\"</span>: [\r\n        <span class=\"hljs-string\">\"${workspaceFolder}/**\"</span>,\r\n        <span class=\"hljs-string\">\"!**/node_modules/**\"</span>\r\n      ],\r\n      <span class=\"hljs-attr\">\"skipFiles\"</span>: [\r\n        <span class=\"hljs-string\">\"&lt;node_internals&gt;/**\"</span>\r\n      ]\r\n    }\r\n  ]\r\n}</code></pre><h2>Что в итоге получилось</h2><p>В результате у меня получился Telegram-канал, в который ежедневно сваливаются несколько интересных статей из мира .NET (без надоедливых рекламных постов).</p><p>Сам канал: <a href=\"https://t.me/amazing_dotnet\" rel=\"noopener noreferrer nofollow\">Amazing .NET</a></p><p><a href=\"https://github.com/Chakrygin/amazing-dotnet\" rel=\"noopener noreferrer nofollow\"><u>Исходники на GitHub</u></a>.</p><p>Сейчас мониторятся следующие сайты:</p><ul><li><p>Коллективные блоги:</p><ul><li><p>Microsoft Developer Blogs:</p><ul><li><p>.NET Blog -&nbsp;<a href=\"https://devblogs.microsoft.com/dotnet/\" rel=\"noopener noreferrer nofollow\">https://devblogs.microsoft.com/dotnet/</a></p></li><li><p>OData -&nbsp;<a href=\"https://devblogs.microsoft.com/odata/\" rel=\"noopener noreferrer nofollow\">https://devblogs.microsoft.com/odata/</a></p></li><li><p>The NuGet Blog -&nbsp;<a href=\"https://devblogs.microsoft.com/nuget/\" rel=\"noopener noreferrer nofollow\">https://devblogs.microsoft.com/nuget/</a></p></li><li><p>TypeScript -&nbsp;<a href=\"https://devblogs.microsoft.com/typescript/\" rel=\"noopener noreferrer nofollow\">https://devblogs.microsoft.com/typescript/</a></p></li><li><p>Visual Studio Blog -&nbsp;<a href=\"https://devblogs.microsoft.com/visualstudio/\" rel=\"noopener noreferrer nofollow\">https://devblogs.microsoft.com/visualstudio/</a></p></li><li><p>Windows Command Line -&nbsp;<a href=\"https://devblogs.microsoft.com/commandline/\" rel=\"noopener noreferrer nofollow\">https://devblogs.microsoft.com/commandline/</a></p></li></ul></li><li><p>The JetBrains Blog / The .NET Tools Blog</p><ul><li><p>How-To\'s - <a href=\"https://blog.jetbrains.com/dotnet/category/how-tos/\" rel=\"noopener noreferrer nofollow\">https://blog.jetbrains.com/dotnet/category/how-tos/</a></p></li><li><p>Releases - <a href=\"https://blog.jetbrains.com/dotnet/category/releases/\" rel=\"noopener noreferrer nofollow\">https://blog.jetbrains.com/dotnet/category/releases/</a></p></li><li><p>.NET Annotated - <a href=\"https://blog.jetbrains.com/dotnet/tag/net-annotated/\" rel=\"noopener noreferrer nofollow\">https://blog.jetbrains.com/dotnet/tag/net-annotated/</a></p></li></ul></li><li><p>Хабр -&nbsp;<a href=\"https://habr.com/ru/hub/net/\" rel=\"noopener noreferrer nofollow\">https://habr.com/ru/hub/net/</a> (Только статьи с рейтингом 10 и выше)</p></li><li><p>Code Maze -&nbsp;<a href=\"https://code-maze.com/\" rel=\"noopener noreferrer nofollow\">https://code-maze.com/</a></p></li></ul></li><li><p>Персональные блоги:</p><ul><li><p>Andrew Lock - .NET Escapades -&nbsp;<a href=\"https://andrewlock.net/\" rel=\"noopener noreferrer nofollow\">https://andrewlock.net/</a></p></li><li><p>Derek Comartin - CodeOpinion -&nbsp;<a href=\"https://codeopinion.com/\" rel=\"noopener noreferrer nofollow\">https://codeopinion.com/</a></p></li><li><p>Wade Gausden - .NET Core Tutorials -&nbsp;<a href=\"https://dotnetcoretutorials.com/\" rel=\"noopener noreferrer nofollow\">https://dotnetcoretutorials.com/</a></p></li><li><p>Khalid Abuhakmeh -&nbsp;<a href=\"https://khalidabuhakmeh.com/\" rel=\"noopener noreferrer nofollow\">https://khalidabuhakmeh.com/</a></p></li></ul></li></ul><p>В ближайших планах есть идеи добавить мониторинг ещё пары блогов и, возможно, YouTube.</p><p></p></div></div>', 'Собираем блоги в телеграмме из бложиков', '2022-05-16 12:45:41', '<div class=\"article-formatted-body article-formatted-body article-formatted-body_version-2\"><p>Будучи .NET разработчиком, я стараюсь периодически просматривать различные ресурсы, связанные с .NET тематикой. Как правило, это различные блоги. Иногда то тут, то там появляются какие-нибудь интересные статьи, на которые стоит обратить внимание.</p><p>Недавно я поймал себя на мысли, что делать это вручную мне как-то поднадоело. Тем более, что просматриваю я обычно одни и те же сайты. А значит время заняться автоматизацией.</p><p>Идея была достаточно проста. Нужен скрипт, который сходит по разным ссылкам, разберёт содержимое и отправит обновление в какой-нибудь telegram-канал. Нужно было только придумать, как этот скрипт запускать и где сохранять результат его работы, чтобы знать, что уже было отправлено, а что нет.</p><p>Я решил использовать в качестве хранилища GitHub, а сам скрипт (написан на TypeScript) запускать по расписанию с помощью GitHub Actions. В этой статье я хочу рассказать про некоторые технические детали реализации и поделиться полученным результатом.</p></div>', 'pic2.jpg', 0);
INSERT INTO `Posts` (`PostId`, `UserId`, `Content`, `Title`, `Date`, `ShortContent`, `Image`, `IsNews`) VALUES
(4, 3, '<div class=\"article-formatted-body article-formatted-body article-formatted-body_version-2\"><div xmlns=\"http://www.w3.org/1999/xhtml\"><p>Разбираемся на практике с API HeadHunter при помощи python.</p><p>Появилась задача анализа вакансий на рынке труда, и осуществлять ее надо базе HeadHunter. Необходимо получить все вакансии определенной компании по всем городам России. Ознакомившись с <a href=\"https://github.com/hhru/api\" rel=\"noopener noreferrer nofollow\"><u>документацией по API на github</u></a>, приступаем к работе.</p><p>Для решения задачи используем python. Импортируем необходимые для работы библиотеки:</p><pre><code class=\"python hljs\"><span class=\"hljs-keyword\">import</span> requests      <span class=\"hljs-comment\"># Для запросов по API</span>\r\n<span class=\"hljs-keyword\">import</span> json          <span class=\"hljs-comment\"># Для обработки полученных результатов</span>\r\n<span class=\"hljs-keyword\">import</span> time          <span class=\"hljs-comment\"># Для задержки между запросами</span>\r\n<span class=\"hljs-keyword\">import</span> os            <span class=\"hljs-comment\"># Для работы с файлами</span>\r\n<span class=\"hljs-keyword\">import</span> pandas <span class=\"hljs-keyword\">as</span> pd  <span class=\"hljs-comment\"># Для формирования датафрейма с результатами</span>\r\n</code></pre><p>Стоит разобраться с такой вещью как areas. Всего существует 9 условных зон (стран):</p><div><div class=\"table\"><div class=\"table table_wrapped\"><table><tbody><tr><td><p align=\"left\">ID страны</p></td><td><p align=\"left\">Название страны</p></td></tr><tr><td><p align=\"left\">5</p></td><td><p align=\"left\">Украина</p></td></tr><tr><td><p align=\"left\">9</p></td><td><p align=\"left\">Азербайджан</p></td></tr><tr><td><p align=\"left\">16</p></td><td><p align=\"left\">Беларусь</p></td></tr><tr><td><p align=\"left\">28</p></td><td><p align=\"left\">Грузия</p></td></tr><tr><td><p align=\"left\">40</p></td><td><p align=\"left\">Казахстан</p></td></tr><tr><td><p align=\"left\">48</p></td><td><p align=\"left\">Кыргызстан</p></td></tr><tr><td><p align=\"left\">97</p></td><td><p align=\"left\">Узбекистан</p></td></tr><tr><td><p align=\"left\">113</p></td><td><p align=\"left\">Россия</p></td></tr><tr><td><p align=\"left\">1001</p></td><td><p align=\"center\">Другие регионы</p></td></tr></tbody></table></div></div></div><p>Для каждой страны имеются свои внутренние зоны, которые можно просмотреть через обращение к HH (https://api.hh.ru/areas) с параметром area равным ID страны. К примеру, для России будет найдено свыше 4 тысяч различных городов, сел и других населенных пунктов.</p><p>Для получения всех стран со всеми их внутренними зонами воспользуемся следующим фрагментом кода: </p><pre><code class=\"python hljs\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">getAreas</span><span class=\"hljs-params\">()</span>:</span>\r\n    req = requests.get(<span class=\"hljs-string\">\'https://api.hh.ru/areas\'</span>)    \r\n    data = req.content.decode()\r\n    req.close()\r\n    jsObj = json.loads(data)\r\n    areas = []\r\n    <span class=\"hljs-keyword\">for</span> k <span class=\"hljs-keyword\">in</span> jsObj:\r\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> range(len(k[<span class=\"hljs-string\">\'areas\'</span>])):\r\n            <span class=\"hljs-keyword\">if</span> len(k[<span class=\"hljs-string\">\'areas\'</span>][i][<span class=\"hljs-string\">\'areas\'</span>]) != <span class=\"hljs-number\">0</span>:                      <span class=\"hljs-comment\"># Если у зоны есть внутренние зоны</span>\r\n                <span class=\"hljs-keyword\">for</span> j <span class=\"hljs-keyword\">in</span> range(len(k[<span class=\"hljs-string\">\'areas\'</span>][i][<span class=\"hljs-string\">\'areas\'</span>])):\r\n                    areas.append([k[<span class=\"hljs-string\">\'id\'</span>], \r\n                                  k[<span class=\"hljs-string\">\'name\'</span>], \r\n                                  k[<span class=\"hljs-string\">\'areas\'</span>][i][<span class=\"hljs-string\">\'areas\'</span>][j][<span class=\"hljs-string\">\'id\'</span>],\r\n                                  k[<span class=\"hljs-string\">\'areas\'</span>][i][<span class=\"hljs-string\">\'areas\'</span>][j][<span class=\"hljs-string\">\'name\'</span>]])\r\n            <span class=\"hljs-keyword\">else</span>:                                                                <span class=\"hljs-comment\"># Если у зоны нет внутренних зон</span>\r\n                areas.append([k[<span class=\"hljs-string\">\'id\'</span>], \r\n                              k[<span class=\"hljs-string\">\'name\'</span>], \r\n                              k[<span class=\"hljs-string\">\'areas\'</span>][i][<span class=\"hljs-string\">\'id\'</span>], \r\n                              k[<span class=\"hljs-string\">\'areas\'</span>][i][<span class=\"hljs-string\">\'name\'</span>]])\r\n    <span class=\"hljs-keyword\">return</span> areas\r\n\r\nareas = getAreas()</code></pre><p>Если интересует запрос по конкретной зоне (стране), то в параметры request нужно указать ID необходимой зоны, к примеру, для России: {\'area\': 113}</p><p>Вот часть того, что будет храниться в переменной areas:</p><figure class=\"full-width \"><img src=\"https://habrastorage.org/r/w1560/getpro/habr/upload_files/9b4/763/6e4/9b47636e4af0da08581799f0c08228f7.png\" width=\"522\" height=\"327\" data-src=\"https://habrastorage.org/getpro/habr/upload_files/9b4/763/6e4/9b47636e4af0da08581799f0c08228f7.png\"><figcaption></figcaption></figure><p>Следующим шагом стоит найти ID работодателей.</p><p>Для этого нужно получить количество работодателей на данный момент и учесть тот факт, что не все порядковые номера существуют и внутренние ограничения API HH на постраничный поиск, глубина которого равна всего 2000 значений. </p><pre><code class=\"python hljs\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">getEmployers</span><span class=\"hljs-params\">()</span>:</span>\r\n    req = requests.get(<span class=\"hljs-string\">\'https://api.hh.ru/employers\'</span>)\r\n    data = req.content.decode()\r\n    req.close()\r\n    count_of_employers = json.loads(data)[<span class=\"hljs-string\">\'found\'</span>]\r\n    employers = []\r\n    i = <span class=\"hljs-number\">0</span>\r\n    j = count_of_employers\r\n    <span class=\"hljs-keyword\">while</span> i &lt; j:\r\n            req = requests.get(<span class=\"hljs-string\">\'https://api.hh.ru/employers/\'</span>+str(i+<span class=\"hljs-number\">1</span>))\r\n            data = req.content.decode()\r\n            req.close()\r\n            jsObj = json.loads(data)\r\n            <span class=\"hljs-keyword\">try</span>:\r\n                employers.append([jsObj[<span class=\"hljs-string\">\'id\'</span>], jsObj[<span class=\"hljs-string\">\'name\'</span>]])\r\n                i += <span class=\"hljs-number\">1</span>\r\n                print([jsObj[<span class=\"hljs-string\">\'id\'</span>], jsObj[<span class=\"hljs-string\">\'name\'</span>]])\r\n            <span class=\"hljs-keyword\">except</span>:\r\n                i += <span class=\"hljs-number\">1</span>\r\n                j += <span class=\"hljs-number\">1</span>\r\n            <span class=\"hljs-keyword\">if</span> i%<span class=\"hljs-number\">200</span> == <span class=\"hljs-number\">0</span>:\r\n                time.sleep(<span class=\"hljs-number\">0.2</span>)\r\n    <span class=\"hljs-keyword\">return</span> employers\r\n    \r\nemployers = getEmployers()\r\n</code></pre><p>Результат того, что будет храниться в переменной employers:</p><figure class=\"\"><img src=\"https://habrastorage.org/r/w1560/getpro/habr/upload_files/eca/d3a/33a/ecad3a33a2bfa8b00c6f7a6d76d7225e.png\" width=\"496\" height=\"122\" data-src=\"https://habrastorage.org/getpro/habr/upload_files/eca/d3a/33a/ecad3a33a2bfa8b00c6f7a6d76d7225e.png\"><figcaption></figcaption></figure><p>Возьмем для примера 2ГИС с ID 64174 и найдем все вакансии по работодателю в разрезе каждой зоны России (ID 113). В функцию getPage в качестве входных параметров сделаем только номер страницы для постраничного поиска и зону, где будем смотреть вакансии.</p><pre><code class=\"python hljs\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">getPage</span><span class=\"hljs-params\">(page, area)</span>:</span>\r\n    params = {\r\n        <span class=\"hljs-string\">\'employer_id\'</span>: <span class=\"hljs-number\">3529</span>,  <span class=\"hljs-comment\"># ID 2ГИС</span>\r\n        <span class=\"hljs-string\">\'area\'</span>: area,         <span class=\"hljs-comment\"># Поиск в зоне</span>\r\n        <span class=\"hljs-string\">\'page\'</span>: page,         <span class=\"hljs-comment\"># Номер страницы</span>\r\n        <span class=\"hljs-string\">\'per_page\'</span>: <span class=\"hljs-number\">100</span>       <span class=\"hljs-comment\"># Кол-во вакансий на 1 странице</span>\r\n    }   \r\n    req = requests.get(<span class=\"hljs-string\">\'https://api.hh.ru/vacancies\'</span>, params)\r\n    data = req.content.decode() \r\n    req.close()\r\n    <span class=\"hljs-keyword\">return</span> data</code></pre><p>Часть кода, где функция getPage и используется:</p><pre><code class=\"python hljs\"><span class=\"hljs-keyword\">for</span> area <span class=\"hljs-keyword\">in</span> areas:\r\n    <span class=\"hljs-keyword\">for</span> page <span class=\"hljs-keyword\">in</span> range(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">20</span>):\r\n        jsObj = json.loads(getPage(page, area[<span class=\"hljs-number\">2</span>]))\r\n        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">not</span> os.path.exists(<span class=\"hljs-string\">\'./areas/\'</span>):\r\n            os.makedirs(<span class=\"hljs-string\">\'./areas/\'</span>)\r\n        nextFileName = <span class=\"hljs-string\">\'./areas/{}.json\'</span>.format(str(area[<span class=\"hljs-number\">2</span>])+<span class=\"hljs-string\">\'_\'</span>+str(area[<span class=\"hljs-number\">3</span>])+<span class=\"hljs-string\">\'_\'</span>+str(page))\r\n        f = open(nextFileName, mode=<span class=\"hljs-string\">\'w\'</span>, encoding=<span class=\"hljs-string\">\'utf8\'</span>)\r\n        f.write(json.dumps(jsObj, ensure_ascii=<span class=\"hljs-literal\">False</span>))\r\n        f.close()\r\n        <span class=\"hljs-keyword\">if</span> (jsObj[<span class=\"hljs-string\">\'pages\'</span>] - page) &lt;= <span class=\"hljs-number\">1</span>:  \r\n            print(<span class=\"hljs-string\">\'[{0}/{1}] Область: {3} ({2}) - {5} ({4}) Вакансий: {6}\'</span>.format(area_list_id+<span class=\"hljs-number\">1</span>, \r\n                                                                         len(areas), \r\n                                                                         area[<span class=\"hljs-number\">0</span>], \r\n                                                                         area[<span class=\"hljs-number\">1</span>], \r\n                                                                         area[<span class=\"hljs-number\">2</span>], \r\n                                                                         area[<span class=\"hljs-number\">3</span>], \r\n                                                                         jsObj[<span class=\"hljs-string\">\'found\'</span>]))\r\n            <span class=\"hljs-keyword\">break</span>\r\n    time.sleep(<span class=\"hljs-number\">0.2</span>)</code></pre><p>Сохраняем промежуточные результаты в формате json для каждой зоны отдельно, в том числе и для зон, где не найдено ни одной вакансии. Теперь сгруппируем их в один файл:</p><pre><code class=\"python hljs\">dt = []\r\n<span class=\"hljs-keyword\">for</span> fl <span class=\"hljs-keyword\">in</span> os.listdir(<span class=\"hljs-string\">\'./areas/\'</span>):\r\n    f = open(<span class=\"hljs-string\">\'./areas/{}\'</span>.format(fl), encoding=<span class=\"hljs-string\">\'utf8\'</span>)\r\n    jsonText = f.read()\r\n    f.close()\r\n    jsonObj = json.loads(jsonText)\r\n    <span class=\"hljs-keyword\">if</span> jsonObj[<span class=\"hljs-string\">\'found\'</span>] != <span class=\"hljs-number\">0</span>:\r\n        <span class=\"hljs-keyword\">for</span> js <span class=\"hljs-keyword\">in</span> jsonObj[<span class=\"hljs-string\">\'items\'</span>]:\r\n            <span class=\"hljs-keyword\">if</span> js[<span class=\"hljs-string\">\'salary\'</span>] != <span class=\"hljs-literal\">None</span>:\r\n                salary_from = js[<span class=\"hljs-string\">\'salary\'</span>][<span class=\"hljs-string\">\'from\'</span>]\r\n                salaty_to = js[<span class=\"hljs-string\">\'salary\'</span>][<span class=\"hljs-string\">\'to\'</span>]\r\n            <span class=\"hljs-keyword\">else</span>:\r\n                salary_from = <span class=\"hljs-literal\">None</span>\r\n                salaty_to = <span class=\"hljs-literal\">None</span>\r\n            <span class=\"hljs-keyword\">if</span> js[<span class=\"hljs-string\">\'address\'</span>] != <span class=\"hljs-literal\">None</span>:\r\n                address_raw = js[<span class=\"hljs-string\">\'address\'</span>][<span class=\"hljs-string\">\'raw\'</span>]\r\n            <span class=\"hljs-keyword\">else</span>:\r\n                address_raw = <span class=\"hljs-literal\">None</span>\r\n            dt.append([\r\n                js[<span class=\"hljs-string\">\'id\'</span>],\r\n                js[<span class=\"hljs-string\">\'premium\'</span>],\r\n                js[<span class=\"hljs-string\">\'name\'</span>],\r\n                js[<span class=\"hljs-string\">\'department\'</span>][<span class=\"hljs-string\">\'name\'</span>],\r\n                js[<span class=\"hljs-string\">\'has_test\'</span>],\r\n                js[<span class=\"hljs-string\">\'response_letter_required\'</span>],\r\n                js[<span class=\"hljs-string\">\'area\'</span>][<span class=\"hljs-string\">\'id\'</span>],\r\n                js[<span class=\"hljs-string\">\'area\'</span>][<span class=\"hljs-string\">\'name\'</span>],\r\n                salary_from, \r\n                salaty_to,\r\n                js[<span class=\"hljs-string\">\'type\'</span>][<span class=\"hljs-string\">\'name\'</span>],\r\n                address_raw,\r\n                js[<span class=\"hljs-string\">\'response_url\'</span>],\r\n                js[<span class=\"hljs-string\">\'sort_point_distance\'</span>],\r\n                js[<span class=\"hljs-string\">\'published_at\'</span>],\r\n                js[<span class=\"hljs-string\">\'created_at\'</span>],\r\n                js[<span class=\"hljs-string\">\'archived\'</span>],\r\n                js[<span class=\"hljs-string\">\'apply_alternate_url\'</span>],\r\n                js[<span class=\"hljs-string\">\'insider_interview\'</span>],\r\n                js[<span class=\"hljs-string\">\'url\'</span>],\r\n                js[<span class=\"hljs-string\">\'alternate_url\'</span>],\r\n                js[<span class=\"hljs-string\">\'relations\'</span>],\r\n                js[<span class=\"hljs-string\">\'employer\'</span>][<span class=\"hljs-string\">\'id\'</span>],\r\n                js[<span class=\"hljs-string\">\'employer\'</span>][<span class=\"hljs-string\">\'name\'</span>],\r\n                js[<span class=\"hljs-string\">\'snippet\'</span>][<span class=\"hljs-string\">\'requirement\'</span>],\r\n                js[<span class=\"hljs-string\">\'snippet\'</span>][<span class=\"hljs-string\">\'responsibility\'</span>],\r\n                js[<span class=\"hljs-string\">\'contacts\'</span>],\r\n                js[<span class=\"hljs-string\">\'schedule\'</span>][<span class=\"hljs-string\">\'name\'</span>],\r\n                js[<span class=\"hljs-string\">\'working_days\'</span>],\r\n                js[<span class=\"hljs-string\">\'working_time_intervals\'</span>],\r\n                js[<span class=\"hljs-string\">\'working_time_modes\'</span>],\r\n                js[<span class=\"hljs-string\">\'accept_temporary\'</span>]\r\n                ])</code></pre><p>Полученный промежуточный результат сохраняем в DataFrame и сохраняем как файл Excel.</p><pre><code class=\"python hljs\">df = pd.DataFrame(dt, columns = [\r\n                                <span class=\"hljs-string\">\'id\'</span>,\r\n                                <span class=\"hljs-string\">\'premium\'</span>,\r\n                                <span class=\"hljs-string\">\'name\'</span>,\r\n                                <span class=\"hljs-string\">\'department_name\'</span>,\r\n                                <span class=\"hljs-string\">\'has_test\'</span>,\r\n                                <span class=\"hljs-string\">\'response_letter_required\'</span>,\r\n                                <span class=\"hljs-string\">\'area_id\'</span>,\r\n                                <span class=\"hljs-string\">\'area_name\'</span>,\r\n                                <span class=\"hljs-string\">\'salary_from\'</span>, \r\n                                <span class=\"hljs-string\">\'salaty_to\'</span>,\r\n                                <span class=\"hljs-string\">\'type_name\'</span>,\r\n                                <span class=\"hljs-string\">\'address_raw\'</span>,\r\n                                <span class=\"hljs-string\">\'response_url\'</span>,\r\n                                <span class=\"hljs-string\">\'sort_point_distance\'</span>,\r\n                                <span class=\"hljs-string\">\'published_at\'</span>,\r\n                                <span class=\"hljs-string\">\'created_at\'</span>,\r\n                                <span class=\"hljs-string\">\'archived\'</span>,\r\n                                <span class=\"hljs-string\">\'apply_alternate_url\'</span>,\r\n                                <span class=\"hljs-string\">\'insider_interview\'</span>,\r\n                                <span class=\"hljs-string\">\'url\'</span>,\r\n                                <span class=\"hljs-string\">\'alternate_url\'</span>,\r\n                                <span class=\"hljs-string\">\'relations\'</span>,\r\n                                <span class=\"hljs-string\">\'employer_id\'</span>,\r\n                                <span class=\"hljs-string\">\'employer_name\'</span>,\r\n                                <span class=\"hljs-string\">\'snippet_requirement\'</span>,\r\n                                <span class=\"hljs-string\">\'snippet_responsibility\'</span>,\r\n                                <span class=\"hljs-string\">\'contacts\'</span>,\r\n                                <span class=\"hljs-string\">\'schedule_name\'</span>,\r\n                                <span class=\"hljs-string\">\'working_days\'</span>,\r\n                                <span class=\"hljs-string\">\'working_time_intervals\'</span>,\r\n                                <span class=\"hljs-string\">\'working_time_modes\'</span>,\r\n                                <span class=\"hljs-string\">\'accept_temporary\'</span>\r\n                                ])   \r\ndf.to_excel(<span class=\"hljs-string\">\'result_2gis.xlsx\'</span>)</code></pre><p>Скриншот части конечного результата внутри Excel:</p><figure class=\"full-width \"><img src=\"https://habrastorage.org/r/w1560/getpro/habr/upload_files/d4f/118/472/d4f118472077290d193e98e367e97c4e.png\" width=\"624\" height=\"205\" data-src=\"https://habrastorage.org/getpro/habr/upload_files/d4f/118/472/d4f118472077290d193e98e367e97c4e.png\"><figcaption></figcaption></figure><p>Без особых сложностей, поставленную перед нами задачу выполнили и получили все возможные вакансии по определенному работодателю на разных территориях. </p><p>В этом гайде по работе с API HeadHunter рассмотрен базовый функционал API. Тем не менее, для успешного понимая всего функционала и возможностей, вы можете самостоятельно ознакомиться на <a href=\"https://github.com/hhru/api\" rel=\"noopener noreferrer nofollow\"><u>github HH.ru</u></a> или подождать нашей следующей статьи по данной теме, где мы рассмотрим более сложные примеры.</p><p></p></div></div>', 'Работа с АПИ с помощью змея', '2022-03-08 12:16:16', '<div class=\"article-formatted-body article-formatted-body article-formatted-body_version-2\"><p>Разбираемся на практике с API HeadHunter при помощи python.</p><p>Появилась задача анализа вакансий на рынке труда, и осуществлять ее надо базе HeadHunter. Необходимо получить все вакансии определенной компании по всем городам России. Ознакомившись с документацией по API на github (<a href=\"https://github.com/hhru/api\" rel=\"noopener noreferrer nofollow\">https://github.com/hhru/api</a>), приступаем к работе.</p><p></p></div>', 'pic3.jpg', 0),
(5, 2, '<div class=\"article-formatted-body article-formatted-body article-formatted-body_version-2\">\r\n    <p>\r\n        Штирлиц играл в карты и проигрался. Но Штирлиц умел делать хорошую мину при плохой игре. Когда Штирлиц покинул компанию, мина сработала.\r\n    </p>\r\n<p>\r\nИдет Штирлиц ночью по городу, навстречу мужик бородатый и в чалме.\r\n- Будь он не Ладен - подумал Штирлиц.\r\n</p>\r\n<p>\r\nШтирлиц и Мюллер ездили по очереди на танке. Очередь редела, но не расходилась...\r\n</p>\r\n<p>\r\nШтирлиц стрелял вслепую. Слепая испугалась и побежала скачками, но качки быстро отстали.\r\n</p>\r\n<p>\r\nПодвыпившие Штирлиц и Мюллер вышли из бара.\r\n- Давайте снимем девочек, - предложил Штирлиц.\r\n- У вас очень доброе сердце - ответил Мюллер. - Но пусть все-таки повисят до утра.\r\n</p>\r\n<p>\r\nШтирлиц шёл по улице, когда внезапно перед ним что-то упало. Штирлиц поднял глаза -- это были глаза профессора Плейшнера.\r\n</p>\r\n<p>\r\nШтирлиц вышел из дома и увидел как четыре бугая ставили трактор на попа.\r\n- Бедный пастор Шлаг, -- подумал Штирлиц\r\n</p>\r\n<p>\r\nШтирлиц вытащил из сейфа записку Мюллера. Мюллеру было очень больно и он сильно ругался.\r\n</p>\r\n<p>\r\n-- Штирлиц, вы еврей? -- спросил Мюллер.\r\n-- Я русский, -- с достоинством сказал Штирлиц.\r\n-- А я немецкий, -- усмехнулся Мюллер.\r\n</p>\r\n<p>\r\nКэт подошла к зеркалу и увидела на шее пятно.\r\n\"Засос\", - подумала она, вспомнив, как вчера Штирлиц дал ей по шее за то, что она передала \"СОС\" открытым текстом.\r\n</p>\r\n<p>\r\nШтирлиц упал с балкона и чудом зацепился за другой балкон. Чудо потом распухло и мешало ходить...\r\n</p>\r\n<p>\r\nШтирлицу попала в голову пуля. \"Разрывная,\" - раскинул мозгами Штирлиц.\r\n</p>\r\n<p>\r\nШтирлиц стоял на своем. Это была любимая пытка Мюллера.\r\n</p>\r\n<p>\r\nШтирлиц настаивал на своем. Настойка получалась крепкой, но слегка мутноватой.\r\n</p>\r\n</div>', 'Анекдоты про штирлица', '2022-05-18 11:44:10', '<div class=\"article-formatted-body article-formatted-body article-formatted-body_version-2\">\r\n    <p>\r\n        Штирлиц играл в карты и проигрался. Но Штирлиц умел делать хорошую мину при плохой игре. Когда Штирлиц покинул компанию, мина сработала.\r\n    </p>\r\n<p>\r\nИдет Штирлиц ночью по городу, навстречу мужик бородатый и в чалме.\r\n- Будь он не Ладен - подумал Штирлиц.\r\n</p>\r\n<p>\r\nШтирлиц и Мюллер ездили по очереди на танке. Очередь редела, но не расходилась...\r\n</p>\r\n<p>\r\nШтирлиц стрелял вслепую. Слепая испугалась и побежала скачками, но качки быстро отстали.\r\n</p>\r\n<p>\r\nПодвыпившие Штирлиц и Мюллер вышли из бара.\r\n- Давайте снимем девочек, - предложил Штирлиц.\r\n- У вас очень доброе сердце - ответил Мюллер. - Но пусть все-таки повисят до утра.\r\n</p>\r\n<p>\r\nШтирлиц шёл по улице, когда внезапно перед ним что-то упало. Штирлиц поднял глаза -- это были глаза профессора Плейшнера.\r\n</p>\r\n<p>\r\nШтирлиц вышел из дома и увидел как четыре бугая ставили трактор на попа.\r\n- Бедный пастор Шлаг, -- подумал Штирлиц\r\n</p>\r\n<p>\r\nШтирлиц вытащил из сейфа записку Мюллера. Мюллеру было очень больно и он сильно ругался.\r\n</p>\r\n</div>', NULL, 0),
(6, 3, '<div class=\"article-formatted-body article-formatted-body article-formatted-body_version-2\">\r\n<p>\r\n    Сегодня на экстренном совещании госдумы Жириновский предложил вырвать зубы всем летучим мышам и обвинил их в распространении new коронавирусной инфекции.\r\n</p>\r\n<p>\r\n    Вячеслав Володин (Председатель Госдумы) одобрил эту мысль.\r\n</p>\r\n<p>\r\n    Это предложение будет рассматриваться 29.05.2024 перед экстренным заседанием по поводу газонов в Хакасии партии Славы КПСС.\r\n</p>\r\n</div>', 'Жириновский предложил... перестать предлагать. Как вам идея?', '2022-05-19 12:29:21', '<div class=\"article-formatted-body article-formatted-body article-formatted-body_version-2\">\r\n<p>\r\n    Сегодня на экстренном совещании госдумы Жириновский предложил вырвать зубы всем летучим мышам и обвинил их в распространении new коронавирусной инфекции.\r\n</p>\r\n\r\n</div>', 'jirik.jpg', 1),
(7, 3, '<div class=\"article-formatted-body article-formatted-body article-formatted-body_version-2\">\r\n<p>\r\nЛидер ЛДПР Владимир Жириновский скончался на 76-м году жизни в московской больнице после продолжительной борьбы с COVID-<p>9 и последствиями болезни.\r\nО кончине политика сообщил 6 апреля спикер Государственной думы РФ Вячеслав Володин в своём telegram-канале.\r\n</p>\r\n<p>\r\n\"После тяжёлой и продолжительной болезни ушёл из жизни Владимир Вольфович Жириновский. Яркий, талантливый политик. Человек, который глубоко понимал, как устроен мир, и многое предвидел\", — написал он.\r\nПо словам Володина, Жириновский был одной из ключевых фигур развития политической системы России и подтверждением тому являлась неизменная поддержка российских избирателей.\r\n</p>\r\n<p>\r\n\"Для нас всех — это невосполнимая потеря. Пусть светлая память о нём всегда будет в наших сердцах\", — добавил председатель ГД.\r\nНовости об уходе Жириновского из жизни подтвердила и фракция ЛДПР.\r\n</p>\r\n<p>\r\n\"Это удар для всей России, для армии его сторонников. Из жизни ушёл без преувеличения великий человек, он вписал себя в историю нашей страны и всего мира\", — говорится в сообщении политической силы в telegram-канале.\r\nКак сообщал \"ДП\" ранее, заболевшего коронавирусом политика госпитализировали в Центральную клиническую больницу управделами президента РФ в начале февраля. Спустя </p> недели стало известно, что политику требуется операция, однако её проведение оценивали как небезопасное.\r\n</p>\r\n</div>', 'Жириновский умер...', '2022-04-12 12:42:19', '<div class=\"article-formatted-body article-formatted-body article-formatted-body_version-2\">\r\n<p>\r\nЛидер ЛДПР Владимир Жириновский скончался на 76-м году жизни в московской больнице после продолжительной борьбы с COVID-<p>9 и последствиями болезни.\r\nО кончине политика сообщил 6 апреля спикер Государственной думы РФ Вячеслав Володин в своём telegram-канале.\r\n</p>\r\n<p>\r\n\"После тяжёлой и продолжительной болезни ушёл из жизни Владимир Вольфович Жириновский. Яркий, талантливый политик. Человек, который глубоко понимал, как устроен мир, и многое предвидел\", — написал он.\r\nПо словам Володина, Жириновский был одной из ключевых фигур развития политической системы России и подтверждением тому являлась неизменная поддержка российских избирателей.\r\n</p>\r\n</div>', 'jirik2.jpg', 1),
(8, 3, '<div class=\"article-formatted-body article-formatted-body article-formatted-body_version-2\">\r\n    <p>\r\nЛДПР на своём официальном сайте опровергли информацию о смерти Владимира Жириновского. Состояние политика стабильно, негативных перемен в его здоровье нет. Эту же информацию подтвердили и в федеральном минздраве. Однако просто так спускать распространение такого фейка либерал-демократы не намерены и планируют подать на клеветников иск в генпрокуратуру.\r\n</p>\r\n<p>\r\n«Мы убеждены, что в период, когда страна в стрессе, когда информационный фон и так накалён до предела, подобные фейки — это не просто газетная «утка», а настоящая антигосударственная провокация, которую нельзя спускать с рук», — сказано в сообщении на сайте ЛДПР.\r\n</p>\r\n<p>\r\nНапомним, что Владимир Вольфович находится в состоянии искусственной комы. Политик продолжает получать плановое лечение, врачи оказывают всю необходимую медицинскую помощь.\r\n</p>\r\n</div>', 'Жириновский жив', '2022-04-13 12:46:27', '<div class=\"article-formatted-body article-formatted-body article-formatted-body_version-2\">\r\n    <p>\r\nЛДПР на своём официальном сайте опровергли информацию о смерти Владимира Жириновского. Состояние политика стабильно, негативных перемен в его здоровье нет. Эту же информацию подтвердили и в федеральном минздраве. Однако просто так спускать распространение такого фейка либерал-демократы не намерены и планируют подать на клеветников иск в генпрокуратуру.\r\n</p>\r\n</div>', 'jirik3.jpg', 1);

-- --------------------------------------------------------

--
-- Структура таблицы `Users`
--

CREATE TABLE `Users` (
  `UserId` int(11) NOT NULL,
  `Login` varchar(50) NOT NULL,
  `Fullname` varchar(70) NOT NULL,
  `Address` varchar(200) NOT NULL,
  `Image` varchar(100) NOT NULL,
  `Description` varchar(300) NOT NULL,
  `RegDate` date NOT NULL,
  `AboutSelf` text NOT NULL
) ENGINE=MyISAM DEFAULT CHARSET=utf8;

--
-- Дамп данных таблицы `Users`
--

INSERT INTO `Users` (`UserId`, `Login`, `Fullname`, `Address`, `Image`, `Description`, `RegDate`, `AboutSelf`) VALUES
(1, 'dysha', 'Андрей 228', 'Ул. Пушкина, д.Колотушкина', 'ava3.jpg', 'Программерист', '2022-05-01', 'Создатель этого невероятного, 100% оригинального, как и его курсовая, сайта.'),
(2, 'vitya', 'Добудько Виктор Алексеевич', 'ул.Пушкина д.Колотушкина2', 'ava2.jpg', 'Сидит слева ', '2021-06-22', 'Сидит слева и не может починить ссылку, хотя по стилям она должна работать'),
(3, 'CrAzY_CliCk', 'Самохвалов Дмитрий Самосвалович', 'Где то на эльмаше', 'ava1.jpg', 'Сложный логин', '2020-07-05', 'Ультра-правый коммунист'),
(9, 'romazonka', 'Роман Галигулин', 'Москва', 'ava5.jpg', 'Ромазонка', '2022-05-19', 'Московский парень');

--
-- Индексы сохранённых таблиц
--

--
-- Индексы таблицы `Hub`
--
ALTER TABLE `Hub`
  ADD PRIMARY KEY (`HubId`);

--
-- Индексы таблицы `HubPost`
--
ALTER TABLE `HubPost`
  ADD PRIMARY KEY (`HubPostId`) USING BTREE;

--
-- Индексы таблицы `HubUser`
--
ALTER TABLE `HubUser`
  ADD PRIMARY KEY (`HubUserId`);

--
-- Индексы таблицы `Posts`
--
ALTER TABLE `Posts`
  ADD PRIMARY KEY (`PostId`);

--
-- Индексы таблицы `Users`
--
ALTER TABLE `Users`
  ADD PRIMARY KEY (`UserId`);

--
-- AUTO_INCREMENT для сохранённых таблиц
--

--
-- AUTO_INCREMENT для таблицы `Hub`
--
ALTER TABLE `Hub`
  MODIFY `HubId` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=7;

--
-- AUTO_INCREMENT для таблицы `HubPost`
--
ALTER TABLE `HubPost`
  MODIFY `HubPostId` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=27;

--
-- AUTO_INCREMENT для таблицы `HubUser`
--
ALTER TABLE `HubUser`
  MODIFY `HubUserId` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=12;

--
-- AUTO_INCREMENT для таблицы `Posts`
--
ALTER TABLE `Posts`
  MODIFY `PostId` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=13;

--
-- AUTO_INCREMENT для таблицы `Users`
--
ALTER TABLE `Users`
  MODIFY `UserId` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=10;
COMMIT;

/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
